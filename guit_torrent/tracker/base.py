import asyncio
import dataclasses
import socket
import struct
import time
import urllib
from abc import ABC, abstractmethod
from dataclasses import dataclass
from urllib.parse import urlencode, urlparse

from guit_torrent.metainfo import TorrentMetaInfo

DEFAULT_ANNOUNCE_INTERVAL = 2 * 60


class TrackerError(Exception):
    pass


class BaseTracker(ABC):
    def __init__(self, address: urllib.parse.ParseResult, torrent_metainfo: TorrentMetaInfo, peer_id,
                 get_downloaded_cb=None, update_data_cb=None):
        self.address = address
        self.peer_id = peer_id
        self.torrent_metainfo = torrent_metainfo
        self.get_downloaded_cb = get_downloaded_cb
        self.update_data_cb = update_data_cb

        self.connected = False

        self.interval = DEFAULT_ANNOUNCE_INTERVAL
        self.tracker_id = None

        self.last_announce_res = None

        self.last_update = None
        self.error = None

        self.future = None

    def __str__(self):
        return self.address.geturl()

    @classmethod
    def from_url(cls, announce_url: str, torrent_metainfo: TorrentMetaInfo, peer_id: str,
                 get_downloaded_cb=None, update_data_cb=None) -> "BaseTracker":
        from guit_torrent.tracker.http import TrackerHTTP
        from guit_torrent.tracker.udp import TrackerUDP
        parsed_announce_url = urlparse(announce_url)
        scheme = parsed_announce_url.scheme
        protocols = {
            'http': TrackerHTTP,
            'https': TrackerHTTP,
            'udp': TrackerUDP,
        }
        if scheme not in protocols:
            raise ValueError('announce_url uses unknown protocol "{}"'.format(scheme))
        return protocols[scheme](parsed_announce_url, torrent_metainfo, peer_id, get_downloaded_cb, update_data_cb)

    async def close(self):
        if self.future:
            self.future.cancel()

    def can_query(self):
        return not self.last_update or time.time() - self.last_update >= self.interval

    @abstractmethod
    async def _send_announce(self, params: "TrackerRequestParameters") -> "TrackerResponse":
        raise NotImplementedError

    async def announce(self, event: str = None):
        downloaded = 0 if not self.get_downloaded_cb else self.get_downloaded_cb()
        params = TrackerRequestParameters(
            info_hash=self.torrent_metainfo.info_hash,
            peer_id=self.peer_id,
            port=6888,
            uploaded=0,
            downloaded=downloaded,
            left=self.torrent_metainfo.info.total_length - downloaded,
            event="started" if not self.last_update else event,
            trackerid=self.tracker_id
        )
        self.error = None
        try:
            res = await self._send_announce(params)
        except (TimeoutError, TrackerError) as e:
            self.error = f"{type(e).__name__}: {str(e)}"
            return TrackerResponse(failure_reason=self.error)
        if res.failure_reason:
            self.error = res.failure_reason

        self.interval = max(DEFAULT_ANNOUNCE_INTERVAL, res.min_interval or 0, res.interval or 0)
        self.tracker_id = res.tracker_id
        self.last_update = time.time()

        if self.update_data_cb and (not self.last_announce_res or
                                    (res.incomplete != self.last_announce_res.incomplete or
                                     res.complete != self.last_announce_res.complete or
                                     res.peers != self.last_announce_res.peers)):
            self.update_data_cb(res.incomplete, res.complete, res.peers)
        self.last_announce_res = res

    async def start(self):
        while not self.error:
            await self.announce()
            if not self.error:
                await asyncio.sleep(self.interval)
        await self.close()


@dataclass
class TrackerRequestParameters:
    """Parameters in request sent to tracker"""

    """info_hash: urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file. Note that the 
    value will be a bencoded dictionary, given the definition of the info key above."""
    info_hash: bytes
    """peer_id: urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup. 
    This is allowed to be any value, and may be binary data. There are currently no guidelines for generating this 
    peer ID. However, one may rightly presume that it must at least be unique for your local machine, thus should 
    probably incorporate things like process ID and perhaps a timestamp recorded at startup. See peer_id below for 
    common client encodings of this field."""
    peer_id: str
    """port: The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889. 
    Clients may choose to give up if it cannot establish a port within this range."""
    port: int
    """uploaded: The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten 
    ASCII. While not explicitly stated in the official specification, the concensus is that this should be the total 
    number of bytes uploaded."""
    uploaded: int
    """downloaded: The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten 
    ASCII. While not explicitly stated in the official specification, the consensus is that this should be the total 
    number of bytes downloaded."""
    downloaded: int
    """left: The number of bytes this client still has to download in base ten ASCII. Clarification: The number of 
    bytes needed to download to be 100% complete and get all the included files in the torrent."""
    left: int
    """compact: Setting this to 1 indicates that the client accepts a compact response. The peers list is replaced by 
    a peers string with 6 bytes per peer. The first four bytes are the host (in network byte order), the last two 
    bytes are the port (again in network byte order). It should be noted that some trackers only support compact 
    responses (for saving bandwidth) and either refuse requests without "compact=1" or simply send a compact response 
    unless the request contains "compact=0" (in which case they will refuse the request.)"""
    compact: int = 1
    """no_peer_id: Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if 
    compact is enabled."""
    no_peer_id: int = 0
    """event: If specified, must be one of started, completed, stopped, (or empty which is the same as not being 
    specified). If not specified, then this request is one performed at regular intervals. started: The first request 
    to the tracker must include the event key with this value. stopped: Must be sent to the tracker if the client is 
    shutting down gracefully. completed: Must be sent to the tracker when the download completes. However, 
    must not be sent if the download was already 100% complete when the client started. Presumably, this is to allow 
    the tracker to increment the "completed downloads" metric based solely on this event."""
    event: str = None
    """ip: Optional. The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 
    address. Notes: In general this parameter is not necessary as the address of the client can be determined from 
    the IP address from which the HTTP request came. The parameter is only needed in the case where the IP address 
    that the request came in on is not the IP address of the client. This happens if the client is communicating to 
    the tracker through a proxy (or a transparent web proxy/cache.) It also is necessary when both the client and the 
    tracker are on the same local side of a NAT gateway. The reason for this is that otherwise the tracker would give 
    out the internal (RFC1918) address of the client, which is not routable. Therefore the client must explicitly 
    state its (external, routable) IP address to be given out to external peers. Various trackers treat this 
    parameter differently. Some only honor it only if the IP address that the request came in on is in RFC1918 space. 
    Others honor it unconditionally, while others ignore it completely. In case of IPv6 address (e.g.: 
    2001:db8:1:2::100) it indicates only that client can communicate via IPv6."""
    ip: str = None
    """numwant: Optional. Number of peers that the client would like to receive from the tracker. This value is 
    permitted to be zero. If omitted, typically defaults to 50 peers."""
    numwant: int = 50
    """key: Optional. An additional identification that is not shared with any other peers. It is intended to allow a 
    client to prove their identity should their IP address change."""
    key: int = 32423
    """trackerid: Optional. If a previous announce contained a tracker id, it should be set here."""
    trackerid: str | None = None

    def get_url_query(self):
        return urlencode({key: val for key, val in dataclasses.asdict(self).items() if val is not None})

    @property
    def event_numeral(self):
        match self.event:
            case "started":
                return 2
            case "completed":
                return 1
            case "stopped":
                return 3
            case _:
                return 0


@dataclass
class TrackerResponse:
    """Response to our request to the tracker"""

    """failure reason: If present, then no other keys may be present. The value is a human-readable error message as 
    to why the request failed (string)."""
    failure_reason: str = None
    """warning message: (new, optional) Similar to failure reason, but the response still gets processed normally. 
    The warning message is shown just like an error."""
    warning_message: str = None
    """interval: Interval in seconds that the client should wait between sending regular requests to the tracker"""
    interval: int = 0
    """min interval: (optional) Minimum announce interval. If present clients must not reannounce more frequently 
    than this."""
    min_interval: int = 0
    """tracker id: A string that the client should send back on its next announcements. If absent and a previous 
    announce sent a tracker id, do not discard the old value; keep using it."""
    tracker_id: str = None
    """complete: number of peers with the entire file, i.e. seeders (integer)"""
    complete: int = 0
    """incomplete: number of non-seeder peers, aka "leechers" (integer)"""
    incomplete: int = 0
    """peers: (dictionary model) The value is a list of dictionaries, each with the following keys:
        peer id: peer's self-selected ID, as described above for the tracker request (string)
        ip: peer's IP address either IPv6 (hexed) or IPv4 (dotted quad) or DNS name (string)
        port: peer's port number (integer)"""
    """peers: (binary model) Instead of using the dictionary model described above, the peers value may be a string 
    consisting of multiples of 6 bytes. First 4 bytes are the IP address and last 2 bytes are the port number. All in 
    network (big endian) notation."""
    peers: tuple[tuple[str, int], ...] = None

    def __post_init__(self):
        if isinstance(self.peers, bytes):
            # convert to list[tuple[str, int]]
            self.peers = tuple(set(
                (socket.inet_ntoa(self.peers[i: i + 4]), struct.unpack("!H", self.peers[i + 4: i + 6])[0])
                for i in range(0, len(self.peers), 6)
            ))
        if self.peers is None:
            self.peers = tuple()
